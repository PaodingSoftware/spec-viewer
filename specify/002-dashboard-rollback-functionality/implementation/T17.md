# 实现记录 - T17

## 任务信息
- **编号**: T17
- **描述**: 修复讨论重新编号的根本问题：使用正则全局替换（/g 标志）配合回调函数，确保所有讨论标题都被替换，利用计数器递增自动生成连续编号（D01, D02, D03...），彻底解决了之前所有方案的遗漏问题

## 实现细节

### 问题分析
前面的所有方案（D07-D09，对应 T14-T16）都尝试使用循环调用 `String.replace(string, string)` 来重新编号讨论，但这个方法每次只替换第一个匹配项，导致：
- 即使按文件位置排序，也无法保证所有讨论都被正确替换
- 复杂的两阶段替换策略（临时占位符）仍然会因为只替换第一个匹配而失败
- 从上到下遍历替换的方案理论上可行，但实际测试中仍会遗漏某些编号

### 根本原因
`String.replace(searchString, replacement)` 方法（不使用正则表达式时）只会替换字符串中第一次出现的匹配项，无论如何循环或排序都无法保证完全替换。

### 解决方案
使用正则表达式的全局替换（`/g` 标志）配合回调函数：

```javascript
// Renumber all remaining discussions sequentially from D01
// Use a more robust approach: replace all headers using regex with a callback
let discussionCounter = 0;
content = content.replace(/### D\d+ - /g, () => {
    discussionCounter++;
    return `### D${String(discussionCounter).padStart(2, '0')} - `;
});
```

### 实现优势
1. **全局替换**: `/g` 标志确保所有匹配的讨论标题 `### D\d+ - ` 都会被替换
2. **回调函数**: 在每次匹配时调用回调，递增计数器，生成新的编号
3. **按顺序处理**: 正则引擎从上到下按顺序匹配，自动保证编号的连续性
4. **单次完成**: 一次 `replace()` 调用完成所有重新编号，没有中间状态，完全避免替换冲突
5. **代码简洁**: 只需 3 行代码，逻辑清晰易懂
6. **性能更好**: 单次正则匹配比多次字符串查找更高效

### 代码变更

**文件**: `extension/src/providers/dashboard-provider.js`

**位置**: `deleteDiscussion()` 方法中的重新编号逻辑

**原代码** (T16 版本):
```javascript
// Renumber all remaining discussions sequentially from D01
// Extract all remaining discussions with their positions
const discussionRegex = /### (D\d+) - ([^\n]+)\n/g;
let match;
const discussions = [];

while ((match = discussionRegex.exec(content)) !== null) {
    const id = match[1];
    const num = parseInt(id.substring(1), 10);
    discussions.push({
        id,
        num,
        fullMatch: match[0],
        index: match.index
    });
}

// Sort discussions by their position in the file (not by number)
discussions.sort((a, b) => a.index - b.index);

// Renumber all discussions sequentially from D01
// Simply iterate from top to bottom and replace each header
for (let i = 0; i < discussions.length; i++) {
    const newNum = i + 1;
    const newId = `D${String(newNum).padStart(2, '0')}`;

    if (discussions[i].id !== newId) {
        // Replace the old header with the new one
        const oldHeader = `### ${discussions[i].id} -`;
        const newHeader = `### ${newId} -`;
        content = content.replace(oldHeader, newHeader);
    }
}
```

**新代码** (T17 版本):
```javascript
// Renumber all remaining discussions sequentially from D01
// Use a more robust approach: replace all headers using regex with a callback
let discussionCounter = 0;
content = content.replace(/### D\d+ - /g, () => {
    discussionCounter++;
    return `### D${String(discussionCounter).padStart(2, '0')} - `;
});
```

### 测试场景
此方案可以正确处理所有场景：
- 删除第1个讨论 (D01)：剩余讨论重新编号为 D01, D02, D03, D04, D05
- 删除中间讨论 (D04)：剩余讨论重新编号为 D01, D02, D03, D04, D05, D06
- 删除最后一个讨论 (D09)：剩余讨论保持 D01, D02, D03, D04, D05, D06, D07, D08
- 任意组合：无论删除哪个，所有剩余讨论都会从 D01 开始连续编号

### 与之前方案的对比

| 方案    | 核心方法                 | 问题                                   |
| ------- | ------------------------ | -------------------------------------- |
| T14     | 从后往前遍历替换         | `replace()` 只替换第一个匹配，会遗漏   |
| T15     | 两阶段替换（临时占位符） | `replace()` 只替换第一个匹配，仍会遗漏 |
| T16     | 从上到下遍历替换         | `replace()` 只替换第一个匹配，仍会遗漏 |
| **T17** | **正则全局替换 + 回调**  | **`/g` 标志替换所有匹配，完全可靠** ✅  |

---
*创建时间: 2025-10-11*
